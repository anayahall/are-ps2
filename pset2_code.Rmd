---
title: 'Problem Set #2'
author: "Anaya Hall & Christian Miller"
output: pdf_document
---

# Part 1: Theory
# Part 2: Applied: Returns to Scale in Electricity Supply

```{r Setup, include=F}
# Setup
knitr::opts_chunk$set(echo = T, cache = T)
# Options
options(stringsAsFactors = F)
# Packages
library(pacman)
p_load(knitr, kableExtra, WDI, dplyr, readr, magrittr, ggplot2)

```

First, load our OLS function created in Problem Set #1.

```{r OLS function}
ols <- function(data, y, X, intercept = T) {
  # Require the 'dplyr' package
  require(dplyr)
  
  # Function to convert tibble, data.frame, or tbl_df to matrix
  to_matrix <- function(the_df, vars) {
    # Create a matrix from variables in var
    new_mat <- the_df %>%
      #Select the columns given in 'vars'
      select_(.dots = vars) %>%
      # Convert to matrix
      as.matrix()
    # Return 'new_mat'
    return(new_mat)
  }
  
  # Create the y matrix
  y_data <- to_matrix (the_df = data, vars = y)
  # Create the X matrix
  X_data <- to_matrix (the_df = data, vars = X)
  # If 'intercept' is TRUE, then add a column of ones
  if (intercept == T) {
    X_data <- cbind(1,X_data)
    colnames(X_data) <- c("intercept", X)
  }
 
  
  # Calculate beta_hat, y_hat, and residuals
  beta_hat <- solve(t(X_data) %*% X_data) %*% t(X_data) %*% y_data
  y_hat <- X_data %*% beta_hat
  e <- y_data - y_hat
  
  # Useful
  n <- nrow(X_data) # number of observations
  k <- ncol(X_data) # number of independent variables
  dof <- n - k # degrees of freedom
  i <- rep(1,n) # column of ones for demeaning matrix
  A <- diag(i) - (1 / n) * i %*% t(i) # demeaning matrix
  y_star <- A %*% y_data # for SST
  X_star <- A %*% X_data # for SSM
  SST <- drop(t(y_star) %*% y_star)
  SSM <- drop(t(beta_hat) %*% t(X_star) %*% X_star %*% beta_hat)
  SSR <- drop(t(e) %*% e)
  
  # Measures of fit and estimated variance
  R2uc <- drop((t(y_hat) %*% y_hat)/(t(y_data) %*% y_data)) # Uncentered R^2
  R2 <- 1 - SSR/SST # Uncentered R^2
  R2adj <- 1 - (n-1)/dof * (1 - R2) # Adjusted R^2
  AIC <- log(SSR/n) + 2*k/n # AIC
  SIC <- log(SSR/n) + k/n*log(n) # SIC
  s2 <- SSR/dof # s^2
  
  # Measures of fit table
  mof_table_df <- data.frame(R2uc, R2, R2adj, SIC, AIC, SSR, s2)
  mof_table_col_names <- c("$R^2_\\text{uc}$", "$R^2$",
                           "$R^2_\\text{adj}$",
                           "SIC", "AIC", "SSR", "$s^2$")
  mof_table <-  mof_table_df %>% knitr::kable(
    row.names = F,
    col.names = mof_table_col_names,
    digits = 5,
    format.args = list(scientific = T),
    booktabs = T,
    escape = F
    )
  
  # Create export data frame for y, y_hat, X, and e
  export_df <- data.frame(y_data, y_hat, e, X_data) %>% tbl_df()
  colnames(export_df) <- c("y","y_hat","e",colnames(X_data))
  
  # Return
  return(list(n=n, dof=dof, b=beta_hat, vars=export_df, R2uc=R2uc,R2=R2,
              R2adj=R2adj, AIC=AIC, SIC=SIC, s2=s2, SST=SST, SSR=SSR,
              mof_table=mof_table))
}
```

## Question 1:
Read the data into R. Print out the data. Read it. Plot the series and make sure your data are read in correctly. Make sure your data are sorted by size (kwh). [Hint: Check for obvious typos in the data and if you find any fix them!]


```{r read_data}

nerlove <- readxl::read_excel("nerlove.xls", col_names=TRUE)

# Fix typo in 13th row (missing a decimal!)
# DO THIS MORE ELEGANTLY! 
nerlove[13, "PL"] <- 1.81

nerlove
```

```{r plotseries}

nerlove %>%
  ggplot(aes(x=PL, y=TC)) + geom_point() + labs(title="Nerlove Data", x="Price of Labor", y="Total Cost")

```

## Question 2:
Replicate regression I (page 176) in the paper. 

Looks like this-ish:
log(TC - PF) = B0 + B1(Q) + B2(Log(PL)0-log(PF)) + B2(log(PK)-log(PF))


